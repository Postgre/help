Возврат к оглавлению 
Будет на примере показано, как создавать библиотеки: статические, разделяемые и динамические.
Создание статической библиотеки
Файл libhello.h содержит прототип библиотечной функции
void hello(void);
Файл libhello.c содержит реализацию библиотечной функции
#include 
void hello(void){
 printf("Hello, library world.\n");
}
Файл demo_use.c содержит вызов библиотечной функции.
#include "libhello.h"
int main(){
  hello();
  return 0;
}
Теперь создадим статическую библиотеку и создадим исполняемый файл на основе libhello.h, libhello.c, demo_use.c . Ключ -g можно удалить, он используется только для проведения отладки при помощи gdb.
#Создаем объектный файл
gcc -Wall -g -c -o libhello-static.o libhello.c
#Создаем статическую библиотеку
ar rcs libhello-static.a libhello-static.o
#Если обладаете правами суперпользователя, то можно выполнить
#cp libhello-static.a /usr/local/lib/
#Иначе оставляем статическую библиотеку в текущей директории
#Создаем объектный файл
gcc -Wall -g -c demo_use.c -o demo_use.o
#Создаем исполняемый файл
#-L. - этот параметр указывает компилятору, что библиотеку следует искать в текущей директории.
#-lhello-static - этот параметр указывает компилятору, что библиотека помещается в файле
#libhello-static.расширение (.a, .o, .so).
gcc -g -o demo_use_static demo_use.o -L. -lhello-static
#Выполнение исполняемого файла
./demo_use_static
Для выполнения исполняемого файла demo_use_static уже не требуется существование файла libhello.a. Эта библиотека нужна была только при создании исполняемого файла.
Создание разделяемой библиотеки
Способ создания разделяемых библиотек зависит от ОС, однако обычно включает два этапа. Первый этап - создание объектного файла, содержащий код, не зависящий от места расположения (Position-Independent Code). Второй этап - создание собственно библиотеки.
#Создаем объектный файл, пригодный впоследствие для создания разделяемой библиотеки.
#Обращаем внимание на ключ -fPIC
gcc -fPIC -Wall -g -c libhello.c
#Создаем разделяемую библиотеку
#-lc  - этот аргумент указывает, что компиляция происходи с участием стандартной C-библиотеки libc, поскольку libhello.o зависит от  libc
#-Wl - предшествует параметрам, передаваемым линкеру (сборщику исполняемого файла) 
gcc -g -shared -Wl,-soname,libhello.so.0 -o libhello.so.0.0 libhello.c -lc
#Если обладаете правами суперпользователя, то можно выполнить
# cp libhello.so.0.0 /usr/local/lib/
#Ключ -n указывает ldconfig, что обработать нужно только директории указанные в командной строке, в данном случае - только текущую директорию. 
/sbin/ldconfig -v -n .
#Создание символической ссылки
ln -sf libhello.so.0 libhello.so
#Создание объектного файла
gcc -Wall -g -c demo_use.c -o demo_use.o
#Создание исполняемого файла:
#-L. - этот параметр указывает компилятору, что поиск при компиляции необходимо проводить в текущей директории
#-lhello - этот параметр определяет имя файла, в котором содержится необходимая библиотека
gcc -g -o demo_use demo_use.o -L. -lhello

#Для выполнения необходимо, чтобы в переменной окружения LD_LIBRARY_PATH были перечислены через ":" директории, в которых следует искать библиотеки. 
LD_LIBRARY_PATH="." ./demo_use
Для успешного выполнения необходимо, что файлы, содержащие библиотеки, присутствовали в указанных директориях. Если файлов нет в этих директориях, происходит поиск в стандарнтных директориях /lib и /usr/lib. По итогам создания этой статической библиотеки у вас возникнет файл libhello.so, являющийся символической ссылкой на файл libhello.so.0, который в свою очередь является символической ссылкой на файл libhello.so.0.0, который и содержит разделяемую библиотеку. Числа, идущие после "so." , называются версией и релизом библиотеки. Для того, чтобы определить с какими версиями библиотек скомпилирована программа, достаточно воспользоваться командой
ldd demo_use
При выполнении программы происходит поиск библиотеки с требуемым именем и версией, то есть поиск файл с именем lib<имя_библиотеки>.so.номер_версии. Этот файл является символической ссылкой на файл, содержащий собственно библиотеку. В имени этого файла уже будет присутствовать номер релиза. Такой механизм позволяет иметь несколько версий одной библиотеки.
Использование динамических библиотек
Необходимо сначала создать разделяемую библиотеку. Далее приводится текст программы, в которой происходит динамическое подгружение библиотеки.
/* demo_dynamic.c -- demonstrate dynamic loading and
     use of the "hello" routine */


/* Need dlfcn.h for the routines to
     dynamically load libraries */
#include 

#include 
#include 

/* Note that we don't have to include "libhello.h".
     However, we do need to specify something related;
        we need to specify a type that will hold the value
           we're going to get from dlsym(). */

/* The type "simple_demo_function" describes a function that
     takes no arguments, and returns no value: */

typedef void (*simple_demo_function)(void);


int main(void) {
         const char *error;
          void *module;
           simple_demo_function demo_function;

            /* Load dynamically loaded library */
              module = dlopen("libhello.so", RTLD_LAZY);
              if (!module) {
                        fprintf(stderr, "Couldn't open libhello.so: %s\n",
                              exit(1);
                               }

               /* Get symbol */
               dlerror();
               demo_function = dlsym(module, "hello");
                if ((error = dlerror())) {
                           fprintf(stderr, "Couldn't find hello: %s\n", error);
                              exit(1);
                               }

                 /* Now call the function in the DL library */
                 (*demo_function)();

                  /* All done, close things cleanly */
                  dlclose(module);
                   return 0;
}

Компиляция осуществляется следующими командами:
#создаем объектный файл
gcc -Wall -g -c demo_dynamic.c
#создаем исполняемый файл
#-ldl - этот параметр обеспечивает обращение к библиотеке libdl, которая обеспечивает
динамическое подгружение библиотек
gcc -g -o demo_dynamic demo_dynamic.o -ldl
Выполнение программы так же, как в случае разделяемых библиотек.
LD_LIBRARY_PATH="." ./demo_dynamic
Рекомендуется прочитать документацию для функцийй dlopen, dlclose, dlsym, dlerror, ar, ldd,nm.
Функции _init и _fini. 
В библиотеке могут содержаться функции со специальными именами _init и _fini. Функция _init выполняется всегда непосредственно перед загрузкой библиотеки. Функция _fini выполняется всегда непосредственно перед выгрузкой библиотеки. Покажем на примере, как скомпилировать библиотеку, содержащую функцию _init. Файл libhello.c сделаем таким:
#include 
void _init(void){
 printf("Load library!\n");
}
void hello(void){
 printf("Hello, library world?\n");
}

Объектный файл libhello.o создается без проблем. При попытке создать библиотеку получаем ошибку
gcc  -g -shared -Wl,-soname,libhello.so.1 -o libhello.so.1.0 libhello.o -lc
libhello.o: In function `_init':
/home/zubr/demo_library/shared/libhello.c:2: multiple definition of `_init'
/usr/lib/gcc-lib/i386-redhat-linux/2.96/../../../crti.o(.init+0x0): first defined here
collect2: ld returned 1 exit status
Для прояснения проблемы добавим в ключи компилятора -v. Этот ключ позволяет получить подробности работа компилятора.
 gcc  -v -g -shared -Wl,-soname,libhello.so.1 -o libhello.so.1.0 libhello.o -lc

Reading specs from /usr/lib/gcc-lib/i386-redhat-linux/2.96/specs
gcc version 2.96 20000731 (Red Hat Linux 7.3 2.96-110)
 /usr/lib/gcc-lib/i386-redhat-linux/2.96/collect2 -m elf_i386 -shared -o libhello.so.1.0 /usr/lib/gcc-lib/i386-redhat-linux/2.96/../../../crti.o /usr/lib/gcc-lib/i386-redhat-linux/2.96/crtbeginS.o -L/usr/lib/gcc-lib/i386-redhat-linux/2.96 -L/usr/lib/gcc-lib/i386-redhat-linux/2.96/../../.. -soname libhello.so.1 libhello.o -lc -lgcc -lc -lgcc /usr/lib/gcc-lib/i386-redhat-linux/2.96/crtendS.o /usr/lib/gcc-lib/i386-redhat-linux/2.96/../../../crtn.o
libhello.o: In function `_init':
/home/zubr/demo_library/shared/libhello.c:2: multiple definition of `_init'
/usr/lib/gcc-lib/i386-redhat-linux/2.96/../../../crti.o(.init+0x0): first defined here
collect2: ld returned 1 exit status
Отсюда видно, что компилятор gcc указывает среди объектных файлов, подлежащих компиляции командой collect2, файл /usr/lib/crti.o, который содержит функцию _init. Коль скоро имеем две функции с одним и тем же именем, получаем ошибку. Получить желаемое следующим образом. Явно вызовем collect2 с теми же аргументами, которые, за исключением /usr/lib/gcc-lib/i386-redhat-linux/2.96/../../../crti.o .
 /usr/lib/gcc-lib/i386-redhat-linux/2.96/collect2 -m elf_i386 -shared -o libhello.so.1.0 /usr/lib/gcc-lib/i386-redhat-linux/2.96/crtbeginS.o -L/usr/lib/gcc-lib/i386-redhat-linux/2.96 -L/usr/lib/gcc-lib/i386-redhat-linux/2.96/../../.. -soname libhello.so.1 libhello.o -lc -lgcc -lc -lgcc /usr/lib/gcc-lib/i386-redhat-linux/2.96/crtendS.o /usr/lib/gcc-lib/i386-redhat-linux/2.96/../../../crtn.o
Это успешно создает libhello.1.0. Далее создание библиотеки происходит стандартным образом.
/sbin/ldconfig -n .
gcc  -Wall -g -c demo_use.c -o demo_use.o
gcc  -g -o demo_use1 demo_use.o -L. -lhello
Теперь при выполнении demo_use1 получаем
LD_LIBRARY_PATH="." ./demo_use1
Load library!
Hello, library world?
То есть происходит неявный вызов _init, что и требовалось. Примечание: На вашей машине файл, содержащий стандартную функцию _init, может иметь другое имя. Смотрите внимательно в диагностическую информацию gcc. Ключ -nostartfiles для компилятора gcc позволяет не линковать стартовые файлы, в которых присутствуют функции _init и _fini по умолчанию. Использование этого ключа также решает проблему.